# 04 面向对象1

## 面向对象三大特性:封装,继承,多态

## 4.1 继承性

![1](https://user-images.githubusercontent.com/91724689/192191645-6dd60d7b-b7df-4c66-81e2-0d10cb9626ee.JPG)

继承性:多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

此处多个类称为子类(派生类),单独的这个类称为父类(基类或超类).

类继承使用extends关键词,子类将继承父类中的所有属性和方法.

### 4.2 继承的作用:
- 减少了代码冗余,提高代码的复用性.
- 有利于功能的扩展.
- 让类与类之间产生了关系,提供了多态的前提.

### 4.3 继承的特点
-  子类继承了父类，就继承了父类的方法和属性。
-  在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。
-  在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。

### 4.4 继承的规则
- 子类不能直接访问父类中私有的(private)的成员变量和方法。

![2](https://user-images.githubusercontent.com/91724689/192192571-bd90dadd-d924-4536-87a4-0c4a24255991.JPG)

- 只支持单继承和多层继承，不允许多重继承
  - 一个子类只能有一个父类
  - 一个父类可以派生出多个子类

![3](https://user-images.githubusercontent.com/91724689/192192622-5b3500f7-5c21-46a3-89d4-9f12e0adde61.JPG)

## 4.5 方法的重写

**定义:** 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。

**要求:** 
1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
  - 子类不能重写父类中声明为private权限的方法
4. 子类方法抛出的异常不能大于父类被重写方法的异常

**注意:** 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。

![4](https://user-images.githubusercontent.com/91724689/192213609-7aee6140-06c6-4f7d-b331-c60ffc8d5bf5.JPG)
![5](https://user-images.githubusercontent.com/91724689/192213615-aa4c9459-f68e-4377-8c34-bcc4fc38114c.JPG)

## 4.6 四种访问权限修饰符

四种修饰符:public,protected,(缺省),private.均置于 **类的成员** 定义前,用来限定对象对该类成员的访问权限.

![6](https://user-images.githubusercontent.com/91724689/192214072-4fa30839-7111-4f3b-9aea-b73d05cb73ca.JPG)

## 4.7 super关键字

使用super(形参列表)的方式可以调用父类中声明的指定的构造器.

- 使用super调用父类中的指定操作
  - super可用于访问父类中定义的属性
  - super可用于调用父类中定义的成员方法
  - super可用于在子类构造器中调用父类的构造器
- 注意:
  - 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员
  - *super的追溯不仅限于直接父类*
  - super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

### 调用父类的构造器

1. 子类中所有的构造器默认都会访问父类中空参数的构造器
2. 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且 **必须放在构造器的首行**
3. 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错
4. 在子类的多个构造器中,至少有一个类的构造器使用了super,调用父类中的构造器

### this和super的区别

![7](https://user-images.githubusercontent.com/91724689/192225498-38cbda84-417e-4631-aded-44fa7a9748bc.JPG)

### 子类对象的实例化过程

![8](https://user-images.githubusercontent.com/91724689/192226083-40c9d4ce-4e69-4dc7-8343-2ea01cca47ae.JPG)

1. 从结果上来看:
  - 子类继承父类之后,就获取了父类中声明的属性和方法.
  - 创建子类的对象,在堆空间中就会加载所有父类中声明的属性.
2. 从过程上来看
  - 当通过子类的构造器创建子类对象时,一定会直接或间接的调用其父类的构造器,进而调用父类的父类的构造器.....直到调用了java.lang.Object类中的空参构造器为止.正因为加载过所有父类的结构,所以内存中才有父类的结构,子类对象才可以进行调用.


**注意:**
虽然创建子类对象时调用了父类的构造器,但是自始至终只创建了一个对象,即为new的子类对象

## *Lab1,类的继承*

在子类CheckAccount的withdraw取款方法中,当余额满足取款额的需求时,有三种方式修改余额:

1. 利用父类中提供的setBalance方法
2. 修改父类中余额balance的权限,将private改成protected,使得子类也能直接修改balance
3. (提倡:)使用super.withdraw(amount),直接调用父类的withdraw方法.因为在这一步的操作子类与父类完全一致

```
if(amount <= getBalance()){
  //方法一:
  //super.withdraw(amount);
  //方法二:父类中改成protected
  balance = getBalance() - amount;
}
```
