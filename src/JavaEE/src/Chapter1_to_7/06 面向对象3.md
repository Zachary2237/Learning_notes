# 06 面向对象3

## 面向对象三大特性:封装,继承,多态

## 6.1 static关键字

1. static:静态的
2. static:可以用来修饰属性,方法,代码块,内部类
3. 使用static修饰属性:静态变量
  - 属性,按是否使用static修饰,又分为静态属性和非静态属性(实例变量)
  - 实例变量:我们创建了类的多个对象,每个对象都独立的拥有一套类中的非静态属性.当修改其中一个对象中的非静态属性时,不会导致其他对象中同样的属性值的修改.
  - 静态变量:我们创建了类的多个对象,多个对象共享同一个静态变量.当通过某一个对象修改静态变量时,会导致其他对象调用此静态变量时,是修改过的
  - static修饰属性的其他说明:
    - 静态变量随着类的加载而加载,可以通过"类.静态变量"的方式进行调用
    - 静态变量的加载要早于对象的创建
    - 由于类只会加载一次,则静态变量在内存中也只会存在一份,存在方法区的静态域中
  - 静态属性举例:System.out;Math.PI

4. 使用static修饰方法:静态方法
- 随着类的加载而加载,可以通过"类.静态方法"的方式进行调用
- 静态方法中只能调用静态的方法或属性,非静态方法中,既可以调用非静态的方法或属性也可以调用静态的方法或属性

5. static注意点:
- 在静态的方法内,不能使用this关键字,super关键字
- 关于静态属性和静态方法的使用,均从生命周期的角度去理解

6. 开发中,如何确定一个属性是否声明为static:
  - 属性是可以被多个对象所共享的,不会随着对象的不同而不同的
  - 类中的常量也常常声明为static

7. 开发中,如何确定一个方法是否声明为static:
  - 操作静态属性的方法,通常设置为static的
  - 工具类中的方法,习惯上声明为static的,如:Math,Arrays,Collections

## 6.2 单例设计模式

![3](https://user-images.githubusercontent.com/91724689/194228316-67402ee4-94f8-4c5f-a548-5d6c6129f18a.JPG)

单例设计模式:饿汉式和懒汉式

饿汉式:
  - 好处:饿汉式是线程安全的
  - 坏处:对象加载时间过长

懒汉式:
  - 好处:延迟对象的创建
  - 坏处:(目前的写法)线程不安全,多线程时可修复

单例模式的优点:减少系统性能的开销

![2](https://user-images.githubusercontent.com/91724689/194512224-c29696da-c3a1-4d6e-956c-acbe94ccecfd.JPG)

## 6.3 理解main()方法

1. main()方法作为程序的入口
2. main()方法也是一个普通的静态方法
3. main()方法也可以作为与控制台交互的方式

## 6.4 代码块(初始化块)

1. 代码块的作用:用来初始化类,对象
2. 代码块如果有修饰的话,只能使用static
3. 分类:静态代码块 vs 非静态代码块
4. 静态代码块:
  - 内部可以有输出语句
  - 随着类的加载而执行
  - 作用:初始化类的信息
  - 如果一个类中定义了多个静态代码块,则按照声明的先后顺序执行
  - 静态代码块的执行要优先于非静态代码块的执行
  - 静态代码块内只能调用静态的属性,静态的方法,不能调用非静态的结构

5. 非静态代码块:
  - 内部可以有输出语句
  - 随着对象的创建而执行,而且只执行一次
  - 每创建一个对象,就执行一次
  - 作用:可以在创建对象时,对对象的属性等进行初始化
  - 如果一个类中定义了多个非静态代码块,则按照声明的先后顺序执行
  - 非静态代码块内可以调用静态的属性,静态的方法,或非静态的属性,非静态的方法
6. 代码块的执行先于构造器

**总结:** 由父及子,静态先行

[补充:]对属性可以赋值的位置(有顺序):
- 默认初始化
- 显式初始化/在代码块中赋值
- 构造器中初始化
- 有了对象之后,通过"对象.属性"或"对象.方法"进行赋值

## 6.5 final 关键字

final:最终的

1. final可以用来修饰的结构:类,方法,变量
2. final用来修饰一个类:此类不能被其他类所继承,如String类,System类,StringBuffer类
3. final用来修饰方法:表明此方法不可以被重写,如Object类中的getClass()
4. final用来修饰变量:此时的"变量"就称为是一个常量
  - final修饰属性:可以考虑赋值的位置有:显式初始化,代码块中初始化,构造器中初始化
  - final修饰局部变量:尤其是使用final修饰形参时,表明此形参是一个常量,当我们调用此方法时,给常量形参赋一个实参,一旦赋值以后,就只能在方法体内使用此形参,但不能进行重新赋值
5. 使用static final 来修饰属性:全局常量

## 6.6 抽象类与抽象方法

abstract关键字的使用:

1. abstract:抽象的
2. abstract可以用来修饰的结构:类,方法
3. abstract修饰类:抽象类
  - 此类不能实例化
  - 抽象类中一定有构造器,便于子类实例化的时候调用
  - 开发中,都会提供抽象类的子类,让子类对象实例化,完成相关操作
4. abstract修饰方法:抽象方法
  - 抽象方法只用方法的声明,没有方法体
  - 包含抽象方法的类一定是抽象类,抽象类中可以没有抽象方法
  - 若子类重写了父类中的所有的抽象方法后,此子类方可实例化;
    若子类没有重写父类中的所有抽象方法,则此子类也是一个抽象类,需要使用abstract进行修饰

## 模板方法设计模式

![4](https://user-images.githubusercontent.com/91724689/194513412-ddd79086-3e21-4256-8473-f94d89a36ad4.JPG)

![5](https://user-images.githubusercontent.com/91724689/194515610-369bbd03-c501-445b-9791-4a4d65880e26.JPG)

## 6.7 接口

接口的使用:
1. 接口使用interface来定义
2. Java中,接口和类是两个并列的结构
3. 如何定义接口:定义接口中的成员  

  3.1 JDK7及以前:只能定义全局常量和抽象方法
    - 全局常量:public static final的,但是书写时可以忽略不写
    - 抽象方法:public abstract的
    
  3.2 JDK8:除了定义全局常量和抽象方法之外,还可以定义静态方法(static),默认方法(default)
    - 接口中定义的静态方法只能通过接口来调用
    - 如果实现类重写了接口中的默认方法,调用时,仍然调用的是重写以后的方法
    - 如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法,那么子类在没有重写此方法的情况下,默认调用父类中的同名同参数的方法 ---> 类优先原则
    - 如果实现类实现了多个接口,而多个接口中定义了同名同参数的默认方法,那么在实现类没有重写此方法的情况下,报错 ---> 接口冲突.这需要我们必须在实现类中重写此方法
    - 如何在子类(或实现类)的方法中调用父类,接口中被重写的方法:```Interface.super.method()```
  
4. 接口中不能定义构造器,意味着接口不可以实例化
5. Java开发中,接口通过让类实现(implements)的方式来使用
  - 如果实现类覆盖了接口中的所有抽象方法,则此实现类就可以实例化
  - 如果实现类没有覆盖接口中的所有的抽象方法,则此实现类仍为一个抽象类

6. Java类可以实现多个接口 ---> 弥补了Java单继承性的局限性
  - 格式: class AA extends BB implements CC,DD,EE

7. 接口与接口之间可以继承,而且可以多继承
8. 接口的具体使用,能够体现多态性
9. 接口实际上可以看作是一种规范
10. 开发中,面向接口编程

[面试题:]抽象类和接口有哪些异同

![7](https://user-images.githubusercontent.com/91724689/194684906-87127f47-2406-4f6a-9462-697fc8451057.JPG)
![6](https://user-images.githubusercontent.com/91724689/194684715-9e87a4cf-463d-447b-8c2a-c25c44233e7e.JPG)

[面试题1:]找错误

![8](https://user-images.githubusercontent.com/91724689/194685104-f7175dd8-e368-4bdd-9ef6-22029ad47a49.JPG)

错误:接口和父类是同等地位,两个相同名称的变量会报错,x是不明确的

修改:若想调用父类的x,可以用super:```System.out.println(super.x)```

若想调用接口的x:接口的常量是全局常量,可以直接调用:```System.out.println(A.x)```

[面试题2:]找错误

![9](https://user-images.githubusercontent.com/91724689/194685455-897dcd06-8d30-4084-8751-719fbd5edc36.JPG)

注意:在类Ball中的play()方法,认为是同时重写两个接口的方法

错误:Rollable接口中的ball为全局静态常量,前省略了```public static final```,在类Ball中的play()方法中修改了ball,这是违法的

## 6.8 内部类

1. Java中允许将一个类A声明在另一个类B中,则类A就是内部类,类B成为外部类
2. 内部类的分类:成员内部类(静态,非静态) vs 局部内部类(方法内,代码块内,构造器内)
3. 成员内部类:
  - 一方面,作为外部类的成员:
    - 调用外部类的结构
    - 可以被static修饰
    - 可以被4种不同的权限修饰
  - 另一方面,作为一个类:
    - 类内可以定义属性,方法,构造器等
    - 可以被final修饰,表示此类不能被继承
    - 可以被abstract修饰
4. 比较重要的三个问题
  - 如何实例化成员内部类的对象
  - 如何在成员内部类中区分调用外部类的结构
  - 开发中局部内部类的使用
